# Домашнее задание к занятию "Микросервисы: принципы"

## Задача 1: API Gateway

Рассмотрим наиболее известные реализации API Gateway для микросервисов: nginx, Spring Cloud Gateway, Kubernetes Ingress

Каждая из технологий имеет множество непересекающихся доступных функций, большинство из которых в рамках текущей задачи описывать не нужно, поэтому ограничимся только необходимыми и сравним их:

| Функционал     | Nginx | Sring Cloud Gateway | Kubernetes Ingress |
|----------------|-------|---|--------------------|
| Маршрутизация на основе конфигурации | Да    | Да| Да                 |
| Аутентификация | Да    | Да | Да                 |
| Поддержка HTTPS | Да | Да | Да |

Так как таблица дает слишком мало информации, поясним дополнительно:

Для Nginx конфигурационный файл по умолчанию предоставляет все опции для маршрутизации и настройки https, как и у любого нормального web сервера. Примеры настройки и инструкции можно посмотреть [здесь](https://www.nginx.com/blog/deploying-nginx-plus-as-an-api-gateway-part-1/) Аутентификация на данный момент хорошо поддерживается как минимум пятью способами:
1) базовая аутентификация - обычно используется только в процессе отладки приложений, затем заменяется на более надежную
2) использование сертификатов на стороне клиента (client-side authentication)
3) proxy-перенаправление запросов на аутентификацию произвольному backend приложению, которое будет ее осуществлять, можно также сделать через модуль njs, который предоставляет подмножество языка javascript для расширения функциональности nginx
4) использование lua-nginx-module
5) использование ngx_http_auth_jwt_module для JWT аутентификации

Можно также комбинировать разные способы для разных маршрутов.

Источник: 

https://stackoverflow.com/questions/72434853/ways-of-authentication-with-nginx

Kubernetes Ingress обладает всеми требуемыми возможностями, так как он "под капотом" как раз и построен на Nginx, расширенном с помощью Lua (стандартный предоставляемый по умолчанию Ingress), не говоря уже о том, что он - больше чем просто API Gateway и имеет множество других функциональностей. Кроме того, есть возможность использовать расширенные Ingress контроллеры сторонних разработчиков

Источники: 

https://kubernetes.io/docs/concepts/services-networking/ingress/

https://www.cloud4y.ru/blog/wha-is-ingress-controller/

Spring Cloud Gateway - хорошо проработанная технология, поддерживаемая многочисленным сообществом разработчиков Spring. Предоставляет возможность маршрутизации не только в коде, но и в конфигурационных файлах. Пример: https://www.baeldung.com/spring-cloud-gateway
Здесь описан пример "чистого" использования технологии, однако на ее базе разработаны множество сторонних решений, предоставляющих расширенный функционал, например Spring Cloud Netflix(Eureka), Spring Cloud Consul, множество собственных сервисов API Gateway, от облачных провайдеров, интегрированных с др. их сервисами

В итоге мы должны принять решение о выборе на основе не только этой информации, но и сведений об устройстве информационной системы компании. Необходимо узнать следующее - интегрированы ли микросервисы компании в облачные решения и в какие, используется ли развертывание микросервисов в собственном корпоративном кластере kubernetes, используются ли выделенные кластеры на каких-то кастомных решениях (не kubernetes), например, для особых сервисов, которые в силу их редкости трудно интегрировать в кубер или в облако. На основе этого мы сможем предолжить либо одну, либо даже комбинацию нескольких решений для API Gateway (никто ведь не запрещает нам использовать несколько таких шлюзов, если это необходимо). Например - если используются облачные решения, лучше всего воспользоваться шлюзом от используемого облачно вендора, если он проверен и обеспечивает достаточную надежность. Если в основном используется собственный кластер кубера - рекомендуем одно из решений с Ingress, либо дефолтовый, либо от стороннего разработчика. Если есть редкие трудно интегрируемые другими способами сервисы - дополнительно к главному шлюзу предлагаем развернуть Nginx, так он способен выполнить маршрутизацию практически куда угодно.

## Задача 2: Брокер сообщений

Дополнительно к заявленным требованиям добавим еще два от себя 1) брокер должен быть бесплатным и хорошо поддерживаться сообществом, и не быть устаревшим 2) брокер должен быть доступным для использования в РФ. Это совершенно необходимо в новых условиях. Кроме того, брокеров достаточно много, поэтому рассмотрим самые "ходовые" либо еще пока не очень широко используемые, но доступные в РФ облачные решения.

| Функционал              | RabbitMQ                           | ActiveMQ/Artemis | Kafka      | Yandex Message Queue |
|-------------------------|------------------------------------|------------------|------------|----------------------|
| Кластеризация           | Да                                 | Да               | Да         | Да                   |
| Хранение на диске       | Да                                 | Да               | Да         | Да                   |
| Высокая скорость работы | Да, но при высокой нагрузке падает | Нет              | Да         | Да                   |
| Форматы сообщений       | собственный                        | OpenWire,JMS     | JSON, Avro | информация закрыта   |
| Разделение прав доступа | по очередям                        | по очередям      | по топикам | по ролям             |
| Простота эксплуатации   | Да                                 | Да               | Да         | Да                   |

Отдельно нужно пояснить некоторые малопонятные пункты. Прежде всего - в таблице я указал форматы инкапсуляции сообщений, в задаче не совсем понятно, что имелось ввиду. Поэтому добавлю - что касается форматов самих сообщений, то ВСЕ брокеры поддерживают любые собственные форматы передаваемых сообщение, так как сообщение инкапсулируется в какой-то из форматов для транспортировки и маршрутизации. Кроме того, существуют ограничения на размер сообщений, которые можно регулировать в разных брокерах, что, однако, не отменяет проблем с передачей, если размер сообщений будет слишком большим для ресурсов и конфигурации данного конкретного развернутого экземпляра брокера. Кроме того, нередко словом "формат сообщения" в брокерах в разных источниках описывают тип обработки сообщений, а не сам их формат - то есть работают ли они по типу генератор-потребитель или по типу публикация-подписка. Как правило, все брокеры могут реализовывать оба таких "формата". Это тоже вносит некоторую путаницу в понимание слова "формат сообщений брокера"
Что касается простоты эксплутации - это скорее тема для holywar, так как для каждого брокера разработаны достаточны простые методы его интеграции в разные приложения (например в Spring Boot приложения), которые делают базовую эксплуатацию простой. Однако, каждый из брокеров может потребовать тонкой настройки своей конфигурации, которая всегда является достаточно сложной и требует понимания его работы "под капотом", особенно в тех случаях, когда требуется настроить высокопроизводительное приложение, особенно с кластеризацией брокера.
Для принятия решения для компании недостаточно этих данных. Необходимо дополнительно получить информацию - в каких именно приложениях будет использоваться брокер. Для потоковой обработки очень больших объемов данных больше подходит Kafka. Для гарантированной доставки и сложной маршрутизации - RabbitMQ. Но нужно отметить, что не очень давно этот разрыв стал сокращаться - в RabbitMQ также добавили потоковую обработку данных и возможность повторной обработки сообщений. Но в целом пока производительность ниже, чем у Kafka. Возможно, со временем эта ситуация измениться. На данном этапе я бы рекомендовал в фирме использовать оба этих брокера в зависимости от типа приложений, то есть разные брокеры в разных приложениях. Кроме того, облачные решения для очередей также хорошо масштабируются и лучше интегрируются с теми приложениями, которые развернуты с использованием облачных решений, и они имеют еще более простую эксплуатацию кластера - не нужно заботиться о масштабировании самой компании, это сделает облако. Поэтому, если в компании есть такие приложения, нужно использовать облачную очередь, интегрированную с данным конкретным решением, например, Yandex Message Queue, если используется облако Яндекса, или другие решения в других облаках.