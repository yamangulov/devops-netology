## Задача 1

Архитектор ПО решил проконсультироваться у вас, какой тип БД 
лучше выбрать для хранения определенных данных.

Выберите подходящие типы СУБД для каждой сущности и объясните свой выбор.

Он вам предоставил следующие типы сущностей, которые нужно будет хранить в БД:

- Электронные чеки в json виде

В этом случае я задам архитектору дополнительные вопросы - будет ли хранение чеков участвовать в более сложной структуре хранения данных, предполагающей сложные отношения между сущностями и сложные составные запросы к взаимосвязанным сущностям, а также насколько большая нагрузка предполагается на систему. В зависимости от ответов возможны разные варианты. 1) при небольшой нагрузке вполне можно использовать реляционную БД с хорошей поддержкой типа данных json - очевидно, что Postgresql очень хорошо подходит 2) если нагрузка большая, но нет особой необходимости работать со сложными взаимосвязанными сущностями или работать с ними будут квалифицированные сотрудники - вполне можно сразу использовать документоориентированную БД - mongodb это лучший выбор. Но поскольку речь идет о чеках, то есть бухгалтерских документах строгой отчетности, то нужно предусмотреть правильную настройку транзакций и резервирование 3) есть вариант, когда часть данных сложных связанных сущностей хранится в реляционной БД, а сами чеки - в mongodb, это позволяет быстро и с высокой нагрузкой работать с чеками, но с другими сущностями и сложными запросами работают сотрудники, хорошо владеющие SQL, но слабо знакомые с языком запросов mongodb. Уверен, что есть еще варианты, я описал только те, что показались мне самыми очевидными.

- Склады и автомобильные дороги для логистической компании

Можно было бы использовать и и сетевые БД, но они давно не поддерживаются, а в графовых можно задать не только сложные отношения между узлами, но и вычислять сложные задачи по поиску путей между узлами - чисто математически в графах это легче. Выберем Neo4j

- Генеалогические деревья

Для хранения генеалогических деревьев необходимо 1) schemaless, поскольку информация в каждом узле дерева нечеткая, могут хранится какие угодно сведения о человеке и 2) каждый человек имеет двух родителей и неопределенное число потомков, причем, возможно,от разных браков. Вполне достаточно было бы БД, которая хорошо отражает такие такие связи - сетевой БД. Но чисто сетевые БД в настоящее время потеряли популярность и не поддерживаются, поэтому я бы предложил выбрать графовую БД, например, Neo4j

- Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации

Подходят как redis, так и memcached, memcached я бы препочел, он попроще, а избыточность функций нам не нужна, вообще можно брать любую БД key-value

- Отношения клиент-покупка для интернет-магазина

Реляционная БД обычно используется в таком случае во всех интернет-магазинах, если нет большой нагрузки. Но сейчас часто используют и документоориентированную mongodb для высоконагруженных магазинов в сочетании с реляционной БД, mongodb тоже может реализовывать сложные связи.

## Задача 2

Вы создали распределенное высоконагруженное приложение и хотите классифицировать его согласно 
CAP-теореме. Какой классификации по CAP-теореме соответствует ваша система
(каждый пункт - это отдельная реализация вашей системы и для каждого пункта надо привести классификацию). 
А согласно PACELC-теореме, как бы вы классифицировали данные реализации?

- Данные записываются на все узлы с задержкой до часа (асинхронная запись)

Так как данные записываются в узлы с задержкой, они могут быть несогласованными в отдельный момент времени, ожидается, что они будут согласованными только в конечном итоге, после задержки. Тогда по CAP это будет система PA, по PACELC - PC/EL (то есть при разделении архитектура стремится остаться частично консистентной в пределах отделившегося узла кластера, а если сетевого разделения нет, то есть задержка)

- При сетевых сбоях, система может разделиться на 2 раздельных кластера

В условии этого пункта явно не сказано, что ожидается от системы при разделении на два кластера. На кластеры могут разделится как системы CP, так и системы AP. Поэтому правильного однозначного ответа на этот вопрос нет без дополнительных условий. Необходимо задать архитектору дополнительный вопрос - чем в этих условиях разрешено пожертвовать, доступностью или консистентностью. В первом случае мы получим систему CP - PC/EC, во втором - AP - AP/EC


- Система может не прислать корректный ответ или сбросить соединение

Именно система CP может не выдавать отклики на запрос, нарушая доступность. Поэтому ситуация аналогичная предыдущему пункту с той поправкой, что теперь мы можем выбрать CP - PC/EC


## Задача 3

Могут ли в одной системе сочетаться принципы BASE и ACID? Почему?

**Теоретически принципы BASE и ACID взаимно противоричевы и не могут сочетаться в одной системе в идеальном, абсолютном смысле.** eventually consistent предполагает, что консистентность достижима только в конечном итоге, но не в любой момент времени (противеречие c consistency из ACID). soft state противоречит atomicity и durability - то есть не каждое, а только критичные изменения фиксируются в БД - это не durability, если в транзакцию (если транзакционность все же как-то реализована хотя бы частично) попадет несколько изменений, часть из которых критичные, а часть нет, то в БД вероятно (не уверен, но по лекции я понял это так) попадут только критичные - а это уже не atomicity. isolation вообще имеет технический смысл, если транзакции поддерживаются системой полноценно. 

Однако, вернемся из идеального мира в реальный. Никто не мешает нам поверх системы, построенной на BASE сделать надстройку, которая бы хотя бы частично имитировала ACID за счет наложения дополнительных ограничений функционала для реализации, например, транзакционности. И такой пример существует - это БД mongodb. В ней есть compare-and-set и основанные на этом механизме транзакции, не абсолютно надежные, но все же более-менее приближающиеся к транзакциям ACID систем (https://habr.com/ru/post/153321/). Аналогичная ситуация - БД Neo4j и MarkLogic обеспечивают свойства ACID, и тоже недостаточно надежно (https://medium.com/nuances-of-programming/%D0%B2%D1%8B%D0%B1%D0%BE%D1%80-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-sql-%D0%B8-nosql-acid-%D0%B8-cap-%D1%81%D1%85%D0%B5%D0%BC%D0%B0-%D0%B8-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-6c0e0a861c3b). Но тут надо учесть, что и сами реляционные БД не вполне строго поддерживают ACID, их реализации допускают разные уровни изоляции транзакций и разную степерь совершенства реализации ACID.

**Поэтому, строго говоря, я бы сказал, что принципы BASE и ACID частично совместимы друг с другом в одной системе при условии не вполне точного соблюдения тех и других.**

## Задача 4

Вам дали задачу написать системное решение, основой которого бы послужили:

- фиксация некоторых значений с временем жизни
- реакция на истечение таймаута

Судя по описанию, это должна быть система key-value с функционалом time-to-live, лучше всего подходит redis, но memcached тоже имеет time-to-live, и хотя функционал ее проще, чем у redis, но тоже можно добиться реакции на истечение time-to-live внешними средствами - кодом программы, которая запрашивает значение из кэша, и если его там нет, то реагирует на это - например, забирает значение не из кэша, а запросом. Вообще, думаю, что любая БД типа key-value, в которой тоже есть функционал time-to-live, на это способна.

Вы слышали о key-value хранилище, которое имеет механизм [Pub/Sub](https://habr.com/ru/post/278237/). 
Что это за система? Какие минусы выбора данной системы?

Это однозначно redis. 

Pub/Sub также поддерживается в массе разных брокеров и messaging system: Microsoft Azure ServiceBus Topics, Microsoft Azure EventHub , Microsoft BizTalk Server, RabbitMQ, ZeroMQ , microServiceBus, IBM WebSphere MQ и Apache Kafka - но это уже более сложные системы, чем просто key-value БД.

Недостатки redis:
- высокие требования к оперативной памяти
- синтаксис отличается от SQL и требуется дополнительное изучение
- до версии 2.6 redis не поддерживал автоматическую отказоустойчивость, поэтому в старых приложениях могут быть проблемы с этим, затем была сделана система redis sentinel, которая решает эти проблемы и включена в поставку redis, а с версии 2.8 - включена версия sentinel 2


